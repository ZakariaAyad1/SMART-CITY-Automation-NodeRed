[
  {
    "id": "tab_ds_load",
    "type": "tab",
    "label": "Dataset - Load & Cache",
    "disabled": false,
    "info": "Self-contained CSV analytics (no external API). Reads water_potability_cleaned.csv, caches rows+analytics in flow context."
  },
  {
    "id": "tab_ds_analytics",
    "type": "tab",
    "label": "Dataset - Analytics",
    "disabled": false,
    "info": "Compute stats, correlations, histograms, outliers from cached dataset."
  },
  {
    "id": "tab_ds_http",
    "type": "tab",
    "label": "Dataset - HTTP",
    "disabled": false,
    "info": "HTTP endpoints to retrieve cached analytics + samples."
  },

  {
    "id": "inj_set_path",
    "type": "inject",
    "z": "tab_ds_load",
    "name": "Set CSV path (Windows)",
    "props": [
      { "p": "payload", "v": "C:\\Users\\LENOVO\\Documents\\Ensa\\s9\\systhem dinfo urba et audit\\Tetouan_Smart_Heritage_City\\Barrages\\ataoui\\water quality (3)\\water quality\\water_potability_cleaned.csv", "vt": "str" }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": 0.2,
    "topic": "",
    "x": 170,
    "y": 80,
    "wires": [["fn_store_path"]]
  },
  {
    "id": "fn_store_path",
    "type": "function",
    "z": "tab_ds_load",
    "name": "Store path in global.csvPath",
    "func": "global.set('csvPath', msg.payload);\nmsg.payload = { csvPath: msg.payload };\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 450,
    "y": 80,
    "wires": [["dbg_path"]]
  },
  {
    "id": "dbg_path",
    "type": "debug",
    "z": "tab_ds_load",
    "name": "CSV path",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "csvPath",
    "statusType": "msg.payload",
    "x": 650,
    "y": 80,
    "wires": []
  },

  {
    "id": "inj_load",
    "type": "inject",
    "z": "tab_ds_load",
    "name": "Load CSV now",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 140,
    "y": 140,
    "wires": [["lnk_out_load"]]
  },
  {
    "id": "lnk_out_load",
    "type": "link out",
    "z": "tab_ds_load",
    "name": "LOAD_CSV",
    "mode": "link",
    "links": ["lnk_in_load"],
    "x": 290,
    "y": 140,
    "wires": []
  },
  {
    "id": "lnk_in_load",
    "type": "link in",
    "z": "tab_ds_load",
    "name": "LOAD_CSV",
    "links": ["lnk_out_load", "lnk_out_reload"],
    "x": 120,
    "y": 220,
    "wires": [["fn_set_filename", "fn_clear_cache"]]
  },
  {
    "id": "fn_set_filename",
    "type": "function",
    "z": "tab_ds_load",
    "name": "Set msg.filename from global.csvPath",
    "func": "const csvPath = global.get('csvPath');\nif (!csvPath) {\n  msg.error = 'csvPath not set. Click Set CSV path first.';\n  return [null, msg];\n}\nmsg.filename = csvPath;\nreturn [msg, null];\n",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 220,
    "wires": [["file_in_csv"], ["dbg_load_error"]]
  },
  {
    "id": "fn_clear_cache",
    "type": "function",
    "z": "tab_ds_load",
    "name": "Clear cached analytics",
    "func": "global.set('ds_rows', null);\nglobal.set('ds_stats', null);\nglobal.set('ds_corr', null);\nglobal.set('ds_hists', null);\nglobal.set('ds_outliers', null);\nglobal.set('ds_loaded_at', null);\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 260,
    "wires": []
  },
  {
    "id": "dbg_load_error",
    "type": "debug",
    "z": "tab_ds_load",
    "name": "Load errors",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "error",
    "targetType": "msg",
    "statusVal": "error",
    "statusType": "msg",
    "x": 690,
    "y": 220,
    "wires": []
  },
  {
    "id": "file_in_csv",
    "type": "file in",
    "z": "tab_ds_load",
    "name": "Read CSV file",
    "filename": "filename",
    "filenameType": "msg",
    "format": "utf8",
    "chunk": false,
    "sendError": true,
    "encoding": "none",
    "x": 650,
    "y": 140,
    "wires": [["csv_parse"]]
  },
  {
    "id": "csv_parse",
    "type": "csv",
    "z": "tab_ds_load",
    "name": "CSV -> array of objects",
    "sep": ",",
    "hdrin": true,
    "hdrout": "none",
    "multi": "mult",
    "ret": "\\n",
    "temp": "",
    "skip": "0",
    "strings": true,
    "include_empty_strings": "",
    "include_null_values": "",
    "x": 880,
    "y": 140,
    "wires": [["fn_cast_cache"]]
  },
  {
    "id": "fn_cast_cache",
    "type": "function",
    "z": "tab_ds_load",
    "name": "Cast types + cache ds_rows",
    "func": "const rows = Array.isArray(msg.payload) ? msg.payload : [];\n\nconst numFields = [\n  'ph','Hardness','Solids','Chloramines','Sulfate','Conductivity','Organic_carbon','Trihalomethanes','Turbidity','Potability'\n];\n\nconst casted = rows\n  .filter(r => r && typeof r === 'object')\n  .map((r) => {\n    const out = { ...r };\n    for (const k of numFields) {\n      if (out[k] === '' || out[k] === null || typeof out[k] === 'undefined') {\n        out[k] = null;\n      } else {\n        const n = Number(out[k]);\n        out[k] = Number.isFinite(n) ? n : null;\n      }\n    }\n    return out;\n  });\n\nconst loadedAt = new Date().toISOString();\n// IMPORTANT: use global context so other tabs (Analytics/HTTP) can access it\nglobal.set('ds_rows', casted);\nglobal.set('ds_loaded_at', loadedAt);\n\nmsg.payload = {\n  loaded_rows: casted.length,\n  csvPath: global.get('csvPath'),\n  loaded_at: loadedAt\n};\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1120,
    "y": 140,
    "wires": [["dbg_loaded", "lnk_out_recompute"]]
  },
  {
    "id": "dbg_loaded",
    "type": "debug",
    "z": "tab_ds_load",
    "name": "Loaded",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "loaded_rows",
    "statusType": "msg.payload",
    "x": 1350,
    "y": 120,
    "wires": []
  },

  {
    "id": "lnk_out_recompute",
    "type": "link out",
    "z": "tab_ds_load",
    "name": "RECOMPUTE_ALL",
    "mode": "link",
    "links": ["lnk_in_recompute"],
    "x": 1365,
    "y": 160,
    "wires": []
  },
  {
    "id": "lnk_in_recompute",
    "type": "link in",
    "z": "tab_ds_analytics",
    "name": "RECOMPUTE_ALL",
    "links": ["lnk_out_recompute", "lnk_out_recompute_btn"],
    "x": 140,
    "y": 80,
    "wires": [["fn_compute_stats", "fn_compute_corr", "fn_compute_hists", "fn_compute_outliers"]]
  },

  {
    "id": "inj_recompute",
    "type": "inject",
    "z": "tab_ds_analytics",
    "name": "Recompute ALL analytics",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 200,
    "y": 140,
    "wires": [["lnk_out_recompute_btn"]]
  },

  {
    "id": "inj_compute_stats",
    "type": "inject",
    "z": "tab_ds_analytics",
    "name": "Compute stats only",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 200,
    "y": 200,
    "wires": [["fn_compute_stats"]]
  },
  {
    "id": "inj_compute_corr",
    "type": "inject",
    "z": "tab_ds_analytics",
    "name": "Compute correlations only",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 220,
    "y": 240,
    "wires": [["fn_compute_corr"]]
  },
  {
    "id": "inj_compute_hists",
    "type": "inject",
    "z": "tab_ds_analytics",
    "name": "Compute histograms only",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 220,
    "y": 280,
    "wires": [["fn_compute_hists"]]
  },
  {
    "id": "inj_compute_outliers",
    "type": "inject",
    "z": "tab_ds_analytics",
    "name": "Compute outliers only",
    "props": [{ "p": "payload" }],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 210,
    "y": 320,
    "wires": [["fn_compute_outliers"]]
  },
  {
    "id": "lnk_out_recompute_btn",
    "type": "link out",
    "z": "tab_ds_analytics",
    "name": "RECOMPUTE_ALL",
    "mode": "link",
    "links": ["lnk_in_recompute"],
    "x": 375,
    "y": 140,
    "wires": []
  },

  {
    "id": "fn_compute_stats",
    "type": "function",
    "z": "tab_ds_analytics",
    "name": "Compute stats (mean/std/quantiles + by Potability)",
    "func": "const rows = global.get('ds_rows') || [];\nif (!Array.isArray(rows) || rows.length === 0) {\n  msg.payload = { error: 'No cached ds_rows. Load CSV first.' };\n  return msg;\n}\n\nconst features = ['ph','Hardness','Solids','Chloramines','Sulfate','Conductivity','Organic_carbon','Trihalomethanes','Turbidity'];\n\nfunction summarize(values) {\n  const clean = values.filter(v => Number.isFinite(v)).sort((a,b)=>a-b);\n  const n = clean.length;\n  const missing = values.length - n;\n  if (!n) return { count: 0, missing, mean: null, std: null, min: null, max: null, q25: null, median: null, q75: null };\n  let sum = 0;\n  for (const v of clean) sum += v;\n  const mean = sum / n;\n  let ss = 0;\n  for (const v of clean) ss += (v - mean) * (v - mean);\n  const std = n > 1 ? Math.sqrt(ss / (n - 1)) : 0;\n\n  function quantile(q) {\n    const pos = (n - 1) * q;\n    const base = Math.floor(pos);\n    const rest = pos - base;\n    if (clean[base + 1] === undefined) return clean[base];\n    return clean[base] + rest * (clean[base + 1] - clean[base]);\n  }\n\n  return {\n    count: n,\n    missing,\n    mean,\n    std,\n    min: clean[0],\n    max: clean[n - 1],\n    q25: quantile(0.25),\n    median: quantile(0.5),\n    q75: quantile(0.75)\n  };\n}\n\nconst potability = {0: 0, 1: 0, null: 0};\nfor (const r of rows) {\n  if (r.Potability === 0) potability[0] += 1;\n  else if (r.Potability === 1) potability[1] += 1;\n  else potability.null += 1;\n}\n\nconst fieldStats = {};\nfor (const f of features) {\n  fieldStats[f] = summarize(rows.map(r => r[f]));\n}\nfieldStats.Potability = summarize(rows.map(r => r.Potability));\n\nfunction meansFor(subset) {\n  const out = {};\n  for (const f of features) {\n    const s = summarize(subset.map(r => r[f]));\n    out[f] = s.mean;\n  }\n  return out;\n}\n\nconst rows0 = rows.filter(r => r.Potability === 0);\nconst rows1 = rows.filter(r => r.Potability === 1);\n\nconst stats = {\n  total_rows: rows.length,\n  potability_counts: potability,\n  fields: fieldStats,\n  by_potability_means: {\n    0: meansFor(rows0),\n    1: meansFor(rows1)\n  },\n  computed_at: new Date().toISOString()\n};\n\nglobal.set('ds_stats', stats);\nmsg.payload = stats;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 80,
    "wires": [["dbg_stats"]]
  },
  {
    "id": "dbg_stats",
    "type": "debug",
    "z": "tab_ds_analytics",
    "name": "ds_stats",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "computed_at",
    "statusType": "msg.payload",
    "x": 760,
    "y": 80,
    "wires": []
  },

  {
    "id": "fn_compute_corr",
    "type": "function",
    "z": "tab_ds_analytics",
    "name": "Compute correlations vs Potability (Pearson)",
    "func": "const rows = global.get('ds_rows') || [];\nif (!Array.isArray(rows) || rows.length === 0) {\n  msg.payload = { error: 'No cached ds_rows. Load CSV first.' };\n  return msg;\n}\n\nconst features = ['ph','Hardness','Solids','Chloramines','Sulfate','Conductivity','Organic_carbon','Trihalomethanes','Turbidity'];\n\nfunction pearsonXY(pairs) {\n  // pairs: [{x,y}] filtered to finite\n  const n = pairs.length;\n  if (n < 2) return null;\n  let sx = 0, sy = 0;\n  for (const p of pairs) { sx += p.x; sy += p.y; }\n  const mx = sx / n, my = sy / n;\n  let sxx = 0, syy = 0, sxy = 0;\n  for (const p of pairs) {\n    const dx = p.x - mx;\n    const dy = p.y - my;\n    sxx += dx * dx;\n    syy += dy * dy;\n    sxy += dx * dy;\n  }\n  if (sxx === 0 || syy === 0) return 0;\n  return sxy / Math.sqrt(sxx * syy);\n}\n\nconst corr = [];\nfor (const f of features) {\n  const pairs = [];\n  for (const r of rows) {\n    const x = r[f];\n    const y = r.Potability;\n    if (Number.isFinite(x) && (y === 0 || y === 1)) pairs.push({ x, y });\n  }\n  const r = pearsonXY(pairs);\n  corr.push({ feature: f, r, abs_r: r === null ? null : Math.abs(r), n: pairs.length });\n}\n\ncorr.sort((a,b) => (b.abs_r ?? -1) - (a.abs_r ?? -1));\nconst out = {\n  target: 'Potability',\n  method: 'pearson',\n  correlations: corr,\n  computed_at: new Date().toISOString()\n};\nglobal.set('ds_corr', out);\nmsg.payload = out;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 140,
    "wires": [["dbg_corr"]]
  },
  {
    "id": "dbg_corr",
    "type": "debug",
    "z": "tab_ds_analytics",
    "name": "ds_corr",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "computed_at",
    "statusType": "msg.payload",
    "x": 760,
    "y": 140,
    "wires": []
  },

  {
    "id": "fn_compute_hists",
    "type": "function",
    "z": "tab_ds_analytics",
    "name": "Compute histograms (10 bins per feature)",
    "func": "const rows = global.get('ds_rows') || [];\nif (!Array.isArray(rows) || rows.length === 0) {\n  msg.payload = { error: 'No cached ds_rows. Load CSV first.' };\n  return msg;\n}\n\nconst features = ['ph','Hardness','Solids','Chloramines','Sulfate','Conductivity','Organic_carbon','Trihalomethanes','Turbidity'];\nconst bins = 10;\n\nfunction hist(values) {\n  const clean = values.filter(v => Number.isFinite(v));\n  const n = clean.length;\n  if (!n) return { bins, min: null, max: null, edges: [], counts: Array(bins).fill(0), n: 0 };\n  let min = clean[0], max = clean[0];\n  for (const v of clean) { if (v < min) min = v; if (v > max) max = v; }\n  if (min === max) {\n    return { bins, min, max, edges: [min, max], counts: [n].concat(Array(bins-1).fill(0)), n };\n  }\n  const width = (max - min) / bins;\n  const counts = Array(bins).fill(0);\n  for (const v of clean) {\n    let idx = Math.floor((v - min) / width);\n    if (idx < 0) idx = 0;\n    if (idx >= bins) idx = bins - 1;\n    counts[idx] += 1;\n  }\n  const edges = [];\n  for (let i = 0; i <= bins; i++) edges.push(min + i * width);\n  return { bins, min, max, edges, counts, n };\n}\n\nconst hists = {};\nfor (const f of features) {\n  hists[f] = hist(rows.map(r => r[f]));\n}\n\nconst pot = {0:0,1:0,null:0};\nfor (const r of rows) {\n  if (r.Potability === 0) pot[0]++;\n  else if (r.Potability === 1) pot[1]++;\n  else pot.null++;\n}\n\nconst out = {\n  bins,\n  histograms: hists,\n  potability_counts: pot,\n  computed_at: new Date().toISOString()\n};\nglobal.set('ds_hists', out);\nmsg.payload = out;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 200,
    "wires": [["dbg_hists"]]
  },
  {
    "id": "dbg_hists",
    "type": "debug",
    "z": "tab_ds_analytics",
    "name": "ds_hists (summary)",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload.computed_at",
    "targetType": "msg",
    "statusVal": "computed_at",
    "statusType": "msg.payload",
    "x": 790,
    "y": 200,
    "wires": []
  },

  {
    "id": "fn_compute_outliers",
    "type": "function",
    "z": "tab_ds_analytics",
    "name": "Outliers via z-score (|z|>3) + top rows",
    "func": "const rows = global.get('ds_rows') || [];\nif (!Array.isArray(rows) || rows.length === 0) {\n  msg.payload = { error: 'No cached ds_rows. Load CSV first.' };\n  return msg;\n}\n\nconst features = ['ph','Hardness','Solids','Chloramines','Sulfate','Conductivity','Organic_carbon','Trihalomethanes','Turbidity'];\n\nfunction meanStd(values) {\n  const clean = values.filter(v => Number.isFinite(v));\n  const n = clean.length;\n  if (!n) return { mean: null, std: null, n: 0 };\n  let sum = 0;\n  for (const v of clean) sum += v;\n  const mean = sum / n;\n  let ss = 0;\n  for (const v of clean) ss += (v - mean) * (v - mean);\n  const std = n > 1 ? Math.sqrt(ss / (n - 1)) : 0;\n  return { mean, std, n };\n}\n\nconst params = {};\nfor (const f of features) params[f] = meanStd(rows.map(r => r[f]));\n\nconst outlierCounts = {};\nfor (const f of features) outlierCounts[f] = 0;\n\nconst top = [];\nfor (let i = 0; i < rows.length; i++) {\n  const r = rows[i];\n  let maxAbsZ = 0;\n  let maxFeature = null;\n  for (const f of features) {\n    const v = r[f];\n    const { mean, std } = params[f];\n    if (!Number.isFinite(v) || mean === null || std === null || std === 0) continue;\n    const z = (v - mean) / std;\n    const az = Math.abs(z);\n    if (az > 3) outlierCounts[f] += 1;\n    if (az > maxAbsZ) { maxAbsZ = az; maxFeature = f; }\n  }\n  if (maxAbsZ > 0) {\n    top.push({ index: i, potability: r.Potability, maxAbsZ, maxFeature });\n  }\n}\n\ntop.sort((a,b) => b.maxAbsZ - a.maxAbsZ);\nconst out = {\n  method: 'zscore',\n  threshold: 3,\n  outlier_counts_per_feature: outlierCounts,\n  top_rows_by_max_abs_z: top.slice(0, 20),\n  computed_at: new Date().toISOString()\n};\n\nglobal.set('ds_outliers', out);\nmsg.payload = out;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 260,
    "wires": [["dbg_outliers"]]
  },
  {
    "id": "dbg_outliers",
    "type": "debug",
    "z": "tab_ds_analytics",
    "name": "ds_outliers",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": true,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "computed_at",
    "statusType": "msg.payload",
    "x": 780,
    "y": 260,
    "wires": []
  },

  {
    "id": "http_health",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/health",
    "url": "/ds/health",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 150,
    "y": 80,
    "wires": [["fn_http_health"]]
  },
  {
    "id": "fn_http_health",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Dataset health",
    "func": "const rows = global.get('ds_rows');\nmsg.payload = {\n  csvPath: global.get('csvPath') || null,\n  loaded_at: global.get('ds_loaded_at') || null,\n  rows_cached: Array.isArray(rows) ? rows.length : 0,\n  has_stats: !!global.get('ds_stats'),\n  has_corr: !!global.get('ds_corr'),\n  has_hists: !!global.get('ds_hists'),\n  has_outliers: !!global.get('ds_outliers'),\n  now: new Date().toISOString()\n};\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 390,
    "y": 80,
    "wires": [["http_resp_health"]]
  },
  {
    "id": "http_resp_health",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 80,
    "wires": []
  },

  {
    "id": "http_reload",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "POST /ds/reload",
    "url": "/ds/reload",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 140,
    "wires": [["lnk_out_reload", "fn_http_reload_reply"]]
  },
  {
    "id": "lnk_out_reload",
    "type": "link out",
    "z": "tab_ds_http",
    "name": "LOAD_CSV",
    "mode": "link",
    "links": ["lnk_in_load"],
    "x": 305,
    "y": 140,
    "wires": []
  },
  {
    "id": "fn_http_reload_reply",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Return 202 Accepted",
    "func": "msg.statusCode = 202;\nmsg.payload = { message: 'Reload triggered. Check /ds/health in a moment.' };\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 180,
    "wires": [["http_resp_reload"]]
  },
  {
    "id": "http_resp_reload",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 180,
    "wires": []
  },

  {
    "id": "http_stats",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/stats",
    "url": "/ds/stats",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 240,
    "wires": [["fn_http_get_stats"]]
  },
  {
    "id": "fn_http_get_stats",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Return ds_stats (or 503)",
    "func": "const stats = global.get('ds_stats');\nif (!stats) {\n  msg.statusCode = 503;\n  msg.payload = { error: 'No ds_stats. Load CSV then Recompute ALL analytics.' };\n  return msg;\n}\nmsg.payload = stats;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 390,
    "y": 240,
    "wires": [["http_resp_stats"]]
  },
  {
    "id": "http_resp_stats",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 240,
    "wires": []
  },

  {
    "id": "http_corr",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/corr",
    "url": "/ds/corr",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 300,
    "wires": [["fn_http_get_corr"]]
  },
  {
    "id": "fn_http_get_corr",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Return ds_corr (or 503)",
    "func": "const corr = global.get('ds_corr');\nif (!corr) {\n  msg.statusCode = 503;\n  msg.payload = { error: 'No ds_corr. Load CSV then Recompute ALL analytics.' };\n  return msg;\n}\nmsg.payload = corr;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 300,
    "wires": [["http_resp_corr"]]
  },
  {
    "id": "http_resp_corr",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 300,
    "wires": []
  },

  {
    "id": "http_hists",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/hists",
    "url": "/ds/hists",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 360,
    "wires": [["fn_http_get_hists"]]
  },
  {
    "id": "fn_http_get_hists",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Return ds_hists (or 503)",
    "func": "const h = global.get('ds_hists');\nif (!h) {\n  msg.statusCode = 503;\n  msg.payload = { error: 'No ds_hists. Load CSV then Recompute ALL analytics.' };\n  return msg;\n}\nconst feature = msg.req && msg.req.query ? msg.req.query.feature : null;\nif (feature) {\n  msg.payload = {\n    bins: h.bins,\n    feature,\n    histogram: h.histograms ? h.histograms[feature] : null,\n    computed_at: h.computed_at\n  };\n  if (!msg.payload.histogram) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Unknown feature', feature, available: Object.keys(h.histograms || {}) };\n  }\n  return msg;\n}\nmsg.payload = h;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 360,
    "wires": [["http_resp_hists"]]
  },
  {
    "id": "http_resp_hists",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 360,
    "wires": []
  },

  {
    "id": "http_outliers",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/outliers",
    "url": "/ds/outliers",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 150,
    "y": 420,
    "wires": [["fn_http_get_outliers"]]
  },
  {
    "id": "fn_http_get_outliers",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Return ds_outliers (or 503)",
    "func": "const o = global.get('ds_outliers');\nif (!o) {\n  msg.statusCode = 503;\n  msg.payload = { error: 'No ds_outliers. Load CSV then Recompute ALL analytics.' };\n  return msg;\n}\nmsg.payload = o;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 420,
    "wires": [["http_resp_outliers"]]
  },
  {
    "id": "http_resp_outliers",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 620,
    "y": 420,
    "wires": []
  },

  {
    "id": "http_sample",
    "type": "http in",
    "z": "tab_ds_http",
    "name": "GET /ds/sample",
    "url": "/ds/sample",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 480,
    "wires": [["fn_http_sample"]]
  },
  {
    "id": "fn_http_sample",
    "type": "function",
    "z": "tab_ds_http",
    "name": "Random sample rows",
    "func": "const rows = global.get('ds_rows') || [];\nif (!Array.isArray(rows) || rows.length === 0) {\n  msg.statusCode = 503;\n  msg.payload = { error: 'No cached ds_rows. Load CSV first.' };\n  return msg;\n}\nconst q = (msg.req && msg.req.query) ? msg.req.query : {};\nconst n = Math.max(1, Math.min(50, Number(q.n || 5)));\nconst pot = (q.potability === '0' || q.potability === '1') ? Number(q.potability) : null;\n\nconst pool = (pot === 0 || pot === 1) ? rows.filter(r => r.Potability === pot) : rows;\nif (!pool.length) {\n  msg.statusCode = 400;\n  msg.payload = { error: 'No rows match filter', potability: pot };\n  return msg;\n}\n\nconst sample = [];\nfor (let i = 0; i < n; i++) {\n  const idx = Math.floor(Math.random() * pool.length);\n  sample.push({ index: idx, row: pool[idx] });\n}\n\nmsg.payload = { n, potability: pot, sample };\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 390,
    "y": 480,
    "wires": [["http_resp_sample"]]
  },
  {
    "id": "http_resp_sample",
    "type": "http response",
    "z": "tab_ds_http",
    "name": "",
    "statusCode": "",
    "headers": { "content-type": "application/json" },
    "x": 610,
    "y": 480,
    "wires": []
  }
]
